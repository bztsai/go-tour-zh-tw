並行
Go 將並行作為語言的核心構成。本課將對其進行介紹，並提供了一些示例來展示如何使用它們。

Go 作者組
http://golang.org

* goroutine

_goroutine_ 是由Go運行時環境管理的輕量級線程。

    go f(x, y, z)

開啟一個新的 goroutine 執行

	f(x, y, z)

`f` ， `x` ， `y` 和 `z` 是當前goroutine中定義的，但是在新的goroutine中運行 `f` 。

goroutine 在相同的地址空間中運行，因此訪問共享內存必須進行同步。[[http://golang.org/pkg/sync/][`sync`]] 提供了這種可能，不過在Go中並不經常用到，因為有其他的辦法。（在接下來的內容中會涉及到。）

.play prog/tour/goroutines.go

* channel

channel是有類型的管道，可以用channel操作符 `<-` 對其發送或者接收值。

    ch <- v    // 將 v 送入 channel ch。
    v := <-ch  // 從 ch 接收，並且賦值給 v。

（「箭頭」就是數據流的方向。）

和map與slice一樣，channel使用前必須創建：

    ch := make(chan int)

默認情況下，在另一端準備好之前，發送和接收都會阻塞。這使得goroutine可以在沒有明確的鎖或競態變數的情況下進行同步。

.play prog/tour/channels.go

* 緩衝channel

channel可以是 _帶緩衝的_ 。為 `make` 提供第二個參數作為緩衝長度來初始化一個緩衝 channel：

	ch := make(chan int, 100)

向緩衝 channel 發送數據的時候，只有在緩衝區滿的時候才會阻塞。當緩衝區清空的時候接受阻塞。

修改例子使得緩衝區被填滿，然後看看會發生什麼。

.play prog/tour/buffered-channels.go

* range和close

發送者可以 `close` 一個channel來表示再沒有值會被發送了。接收者可以通過賦值語句的第二參數來測試channel是否被關閉：當沒有值可以接收並且channel已經被關閉，那麼經過

	v, ok := <-ch

之後 `ok` 會被設置為 `false` 。

循環 `for i := range c` 會不斷從channel接收值，直到它被關閉。
        
*注意：* 只有發送者才能關閉channel，而不是接收者。向一個已經關閉的channel發送數據會引起panic。
*還要注意：* channel與文件不同；通常情況下無需關閉它們。只有在需要告訴接收者沒有更多的數據的時候才有必要進行關閉，例如中斷一個 `range` 。

.play prog/tour/range-and-close.go

* select
        
`select` 語句使得一個goroutine在多個通訊操作上等待。

`select` 會阻塞，直到條件分支中的某個可以繼續執行，這時就會執行那個條件分支。當多個都準備好的時候，會隨機選擇一個。

.play prog/tour/select.go

* 默認選擇

當 `select` 中的其他條件分支都沒有準備好的時候，`default` 分支會被執行。

為了非阻塞的發送或者接收，可使用 `default` 分支：

    select {
    case i := <-c:
    	// 使用 i
    default:
	// 從 c 讀取會阻塞
    }
        
.play prog/tour/default-selection.go

* 練習：等價二叉樹

可以用多種不同的二叉樹的葉子節點存儲相同的數列值。例如，這裡有兩個二叉樹保存了序列 1，1，2，3，5，8，13。

.image /content/img/tree.png

用於檢查兩個二叉樹是否存儲了相同的序列的函式在多數語言中都是相當複雜的。這裡將使用Go的並行和channel來編寫一個簡單的解法。

這個例子使用了 `tree` 包，定義了類型：

    type Tree struct {
        Left  *Tree
        Value int
        Right *Tree
    }

* 練習：等價二叉樹

*1.* 實現 `Walk` 函式。

*2.* 測試 `Walk` 函式。

函式 `tree.New(k)` 構造了一個隨機結構的二叉樹，保存了值 `k` ， `2k` ， `3k` ， ... ， `10k` 。
創建一個新的 channel `ch` 並且對其進行步進：

    go Walk(tree.New(1), ch)

然後從 channel 中讀取並且列印 10 個值。應當是值 1，2，3，...，10。
    
*3.* 用 `Walk` 實現 `Same` 函式來檢測是否 `t1` 和 `t2` 存儲了相同的值。

*4.* 測試 `Same` 函式。

`Same(tree.New(1),`tree.New(1))` 應當返回true，而 `Same(tree.New(1),`tree.New(2))` 應當返回false。

.play prog/tour/exercise-equivalent-binary-trees.go

* 練習：Web 爬蟲

在這個練習中，將會使用 Go 的並行特性來並行執行 web 爬蟲。

修改 `Crawl` 函式來並行的抓取 URLs，並且保證不重複。

.play prog/tour/exercise-web-crawler.go

* Where to Go from here...

#appengine: 你可以從
#appengine: [[http://golang.org/doc/install/][安裝Go]]開始，或者下載
#appengine: [[http://code.google.com/appengine/downloads.html#Google_App_Engine_SDK_for_Go][Go App Engine SDK]].

#appengine: 安裝了Go以後，[[http://golang.org/doc/][Go Documentation]]是個很好的接點。
[[http://golang.org/doc/][Go Documentation]]是個很好的接點。
它包含了參考、指南、影片等等更多資料。

若想了解如何組織Go原始碼並在其上工作，可以參閱[[http://www.youtube.com/watch?v=XCsL89YtqCs][這個影片]]，或者閱讀[[http://golang.org/doc/code.html][如何編寫Go原始碼]]。

若有標準庫上的問題需要幫助，可以參考[[http://golang.org/pkg/][包手冊]]。若有語言本身的問題，可參考[[http://golang.org/ref/spec][語言規範]]。

進一步探索Go的並行模型，可參閱
[[http://www.youtube.com/watch?v=f6kdp27TYZs][Go 並行模型]]
([[http://talks.golang.org/2012/concurrency.slide][幻燈片]])
以及
[[https://www.youtube.com/watch?v=QDDwwePbDtw][深入Go並行模型]]
([[http://talks.golang.org/2013/advconc.slide][幻燈片]])
並且閱讀
[[http://golang.org/doc/codewalk/sharemem/][使用通訊共享內存]]
的原始碼之旅。

想要開始編寫Web應用，請參閱
[[http://vimeo.com/53221558][一個簡單的編程環境]]
([[http://talks.golang.org/2012/simple.slide][幻燈片]])
並且閱讀
[[http://golang.org/doc/articles/wiki/][編寫Web應用]]的指南.

[[http://golang.org/doc/codewalk/functions/][Go中的一等公民函式]]展示了有趣的函式類型。

[[http://blog.golang.org/][Go Blog]]裡有更多關於Go的信息可供使用。

想了解更多內容，請造訪[[http://golang.org][golang.org]]。